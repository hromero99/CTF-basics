{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Preparaci\u00f3n CTF Esta doumentaci\u00f3n esta hecha con la intenci\u00f3n de que aquellas personas que no tengan experiencia propia puedan obtener ciertos conocimientos b\u00e1sicos sobre la resoluci\u00f3n de retos que pueden encontrarse en los CTF Jeopardy Autores principales Antonio S\u00e1nchez Moscoso Linkedin H\u00e9ctor Romero L\u00f3pez Linkedin Colaboradores Valet\u00edn Rafael Savariego Fern\u00e1ndez","title":"Inicio"},{"location":"#preparacion-ctf","text":"Esta doumentaci\u00f3n esta hecha con la intenci\u00f3n de que aquellas personas que no tengan experiencia propia puedan obtener ciertos conocimientos b\u00e1sicos sobre la resoluci\u00f3n de retos que pueden encontrarse en los CTF Jeopardy","title":"Preparaci\u00f3n CTF"},{"location":"#autores-principales","text":"Antonio S\u00e1nchez Moscoso Linkedin H\u00e9ctor Romero L\u00f3pez Linkedin","title":"Autores principales"},{"location":"#colaboradores","text":"Valet\u00edn Rafael Savariego Fern\u00e1ndez","title":"Colaboradores"},{"location":"crypto/","text":"El objetivo de estos desaf\u00edos es, a partir de un mensaje cifrado, encontrar su significado real, lo que llamaremos \"flag\". En estos desafios, la obtenci\u00f3n de la flag puede ir desde una simple traducci\u00f3n, a tener en cuenta como se almacena la informaci\u00f3n de usuarios en sistemas UNIX, cracking de contrase\u00f1as, entre otros. En nuestro caso, las flags de los desafios deber\u00e1n introducirse con el formato: flag{FlagEspecifica}","title":"Inicio"},{"location":"crypto/retos/","text":"Retos de Criptograf\u00eda Challenge 1 En primer lugar, descargamos el archivo challenge1.txt , cuyo contenido es: 4C6120666C61672064656C206368616C6C656E67652065733A200A0A3261633337363438316165353436636436383964356239313237356433323465 Este desaf\u00edo se resuelve traduciendo el contendido del archivo challenge1.txt del Hexadecimal. El resultado es: La flag del challenge es: 2ac376481ae546cd689d5b91275d324e Challenge 2 Este desaf\u00edo es muy parecido al Challenge 1, pero cambiando la forma en que se cifra. Siendo el contenido del archivo challenge2.txt : H375Y('-E;F-I;&QA.@H*9FQA9WMU=5]D96-O9&5?9G)E97-T>6QE?0`` Bastar\u00eda con hacer un decodificado desde UU-Encode: El resultado es: Muy sencilla: flag{uu_decode_freestyle} Challenge 3 Descargamos el archivo challenge3.txt , cuyo contenido nos recuerda a c\u00f3mo los sistemas UNIX almacenan la informaci\u00f3n referente a los usuarios del sistema. Como se nos pide la flag relativa al administrador, desencriptamos su hash. El resultado es: iloveyou99! Challenge 4 A partir de aqu\u00ed, los desafios empiezan a complicarse, pues nos ser\u00e1 necesario usar otras herramientas, adem\u00e1s de webs de descifrado. En este desafio, se nos da un archivo comprimido, protected.zip , el cual necesita una contrase\u00f1a para ser descomprimido. Por otro lado, se nos da el archivo challenge4.txt , cuyo contenido es: BRUDAgk7NjA6AAoeFg1ISgQ= Para obtener la contrase\u00f1a del archivo comprimido, usaremos la herramienta \u201czip2john\u201d, definiendo el nombre del archivo ZIP con contrase\u00f1a y redireccionando la salida hacia un archivo el cual contendr\u00e1 el hash extra\u00eddo. Luego, usaremos la herramienta \"John The Ripper\" para obtener la contrase\u00f1a por fuerza bruta, a trav\u00e9s del archivo antes creado v\u00eda \"zip2john\". Ahora, sabemos que la contrase\u00f1a del protected.zip es \"twilight\". Descomprimimos protected.zip y tenemos un nuevo archivo, key.txt , cuyo contenido es \"cyber\". Con esto, ya tenemos todas las piezas del rompecabezas. Para obtener la flag, desciframos el contenido de challenge4.txt a partir de Base64, y el resultado, se vuelve a descifrar, pero desde \"XOR\", usando como clave el contenido de key.txt . En este caso, es recomendable el uso de CyberChef , ya que nos permite encadenar distintos descifrados, de diferentes m\u00e9todos. Challenge 5 Para este desaf\u00edo, usaremos el archivo net2.pcapng , proporcionado en el Challenge 3 del apartado Red. Este archivo lo visualizaremos usando Wireshark, por lo que nos ser\u00e1 \u00fatil conocer la herramienta. Dentro de toda la informaci\u00f3n contenida en el archivo net2.pcapng , nos interesar\u00e1 inspeccionar el paquete 49. En la imagen, podemos ver que desde la direcci\u00f3n 10.0.2.15 se ha enviado un archivo usando el protocolo FTP a la direcci\u00f3n 10.0.2.4, ambas en la misma red privada. El archivo es ThisIsReallyImportant.txt , y su contenido lo podemos ver desde el propio Wireshark. Su contenido, entre otras cosas, tiene una linea que nos recuerda, una vez mas, a un hash. admin:$1$2b00042f7481c7b056c4b410d28f33cf:13064:0:99999:7:::\\n Desencriptamos el hash, y el resultado nos indica el siguiente paso. El contenido es: $HEX[617364660a] Por \u00faltimo, el resultado antes obtenido, lo traducimos del Hexadecimal: El resultado es: asdf Documentado por Valentin Valentin","title":"Retos"},{"location":"crypto/retos/#retos-de-criptografia","text":"","title":"Retos de Criptograf\u00eda"},{"location":"crypto/retos/#challenge-1","text":"En primer lugar, descargamos el archivo challenge1.txt , cuyo contenido es: 4C6120666C61672064656C206368616C6C656E67652065733A200A0A3261633337363438316165353436636436383964356239313237356433323465 Este desaf\u00edo se resuelve traduciendo el contendido del archivo challenge1.txt del Hexadecimal. El resultado es: La flag del challenge es: 2ac376481ae546cd689d5b91275d324e","title":"Challenge 1"},{"location":"crypto/retos/#challenge-2","text":"Este desaf\u00edo es muy parecido al Challenge 1, pero cambiando la forma en que se cifra. Siendo el contenido del archivo challenge2.txt : H375Y('-E;F-I;&QA.@H*9FQA9WMU=5]D96-O9&5?9G)E97-T>6QE?0`` Bastar\u00eda con hacer un decodificado desde UU-Encode: El resultado es: Muy sencilla: flag{uu_decode_freestyle}","title":"Challenge 2"},{"location":"crypto/retos/#challenge-3","text":"Descargamos el archivo challenge3.txt , cuyo contenido nos recuerda a c\u00f3mo los sistemas UNIX almacenan la informaci\u00f3n referente a los usuarios del sistema. Como se nos pide la flag relativa al administrador, desencriptamos su hash. El resultado es: iloveyou99!","title":"Challenge 3"},{"location":"crypto/retos/#challenge-4","text":"A partir de aqu\u00ed, los desafios empiezan a complicarse, pues nos ser\u00e1 necesario usar otras herramientas, adem\u00e1s de webs de descifrado. En este desafio, se nos da un archivo comprimido, protected.zip , el cual necesita una contrase\u00f1a para ser descomprimido. Por otro lado, se nos da el archivo challenge4.txt , cuyo contenido es: BRUDAgk7NjA6AAoeFg1ISgQ= Para obtener la contrase\u00f1a del archivo comprimido, usaremos la herramienta \u201czip2john\u201d, definiendo el nombre del archivo ZIP con contrase\u00f1a y redireccionando la salida hacia un archivo el cual contendr\u00e1 el hash extra\u00eddo. Luego, usaremos la herramienta \"John The Ripper\" para obtener la contrase\u00f1a por fuerza bruta, a trav\u00e9s del archivo antes creado v\u00eda \"zip2john\". Ahora, sabemos que la contrase\u00f1a del protected.zip es \"twilight\". Descomprimimos protected.zip y tenemos un nuevo archivo, key.txt , cuyo contenido es \"cyber\". Con esto, ya tenemos todas las piezas del rompecabezas. Para obtener la flag, desciframos el contenido de challenge4.txt a partir de Base64, y el resultado, se vuelve a descifrar, pero desde \"XOR\", usando como clave el contenido de key.txt . En este caso, es recomendable el uso de CyberChef , ya que nos permite encadenar distintos descifrados, de diferentes m\u00e9todos.","title":"Challenge 4"},{"location":"crypto/retos/#challenge-5","text":"Para este desaf\u00edo, usaremos el archivo net2.pcapng , proporcionado en el Challenge 3 del apartado Red. Este archivo lo visualizaremos usando Wireshark, por lo que nos ser\u00e1 \u00fatil conocer la herramienta. Dentro de toda la informaci\u00f3n contenida en el archivo net2.pcapng , nos interesar\u00e1 inspeccionar el paquete 49. En la imagen, podemos ver que desde la direcci\u00f3n 10.0.2.15 se ha enviado un archivo usando el protocolo FTP a la direcci\u00f3n 10.0.2.4, ambas en la misma red privada. El archivo es ThisIsReallyImportant.txt , y su contenido lo podemos ver desde el propio Wireshark. Su contenido, entre otras cosas, tiene una linea que nos recuerda, una vez mas, a un hash. admin:$1$2b00042f7481c7b056c4b410d28f33cf:13064:0:99999:7:::\\n Desencriptamos el hash, y el resultado nos indica el siguiente paso. El contenido es: $HEX[617364660a] Por \u00faltimo, el resultado antes obtenido, lo traducimos del Hexadecimal: El resultado es: asdf Documentado por Valentin Valentin","title":"Challenge 5"},{"location":"crypto/tools/","text":"CyberChef : Es una herramienta basada en web que nos permitir\u00e1 analizar y decodificar datos f\u00e1cilmente, sin necesidad de utilizar m\u00faltiples herramientas ni utilizar lenguajes de programaci\u00f3n para realizar diferentes acciones. dCodefr : dCode es el sitio universal para descifrar mensajes, hacer trampas en juegos de palabras, resolver acertijos, geocach\u00e9s y b\u00fasquedas del tesoro, etc. Todas las herramientas de juegos, rompecabezas, c\u00f3digos, encriptaciones y diccionarios est\u00e1n disponibles en dcode.fr hashes.com , enfocada s\u00f3lo a Hashes.","title":"Herramientas"},{"location":"forense/","text":"Hoy en d\u00eda, ante cualquier incidente relacionado con la seguridad inform\u00e1tica , se suelen utilizar en mayor o menor medida t\u00e9cnicas de an\u00e1lisis forense , bien para recopilar evidencias de las acciones realizadas por el atacante, para recuperar indicadores de compromiso con el fin de contener y bloquear la amenaza o para ambas cosas. La memoria RAM es uno de los lugares donde podemos encontrar mayor cantidad de artefactos que nos ser\u00e1n de gran utilidad durante la respuesta a un incidente o en el an\u00e1lisis posterior. Podemos encontrar los procesos en ejecuci\u00f3n con sus estructuras de datos que nos aportan muchos y valiosos detalles: puertos de comunicaciones abiertos en el sistema, claves de cifrado que se escriben en memoria durante la ejecuci\u00f3n de los programas que las utilizan, etc. Ya sean programas leg\u00edtimos o maliciosos, todos pasan por la memoria durante su ejecuci\u00f3n. Ref: https://www.redseguridad.com/especialidades-tic/activos-de-informacion/la-importancia-de-la-memoria-ram-en-un-analisis-forense_20201030.html","title":"Inicio"},{"location":"forense/retos/","text":"Retos de Forense Challenge 1: Profile Description Determina el perfil de S.O. a utilizar con este volcado de memoria. Solution Lo primero es ver antes que tipo de SO nos encontramos, para ello el comando imageinfo nos ofrece una visi\u00f3n general sobre el volcado de memoria. Nosotros para determinar el profile del SO nos vamos a fijar en el campo que pone Suggested Profile . /opt/volatility -f dump.raw imageinfo C\u00f3mo vemos en la figura estamos ante un Windows 7 Service Pack 1 de 64bits . Respuesta: flag{Win7SP1x64} Challenge 2: Procesos Description \u00bfCu\u00e1ntos procesos hab\u00eda en ejecuci\u00f3n en el equipo en el momento de la captura? Solution \u00bf Qu\u00e9 es un proceso? Un proceso es una instancia de un programa en ejecuci\u00f3n. Programas y procesos son entidades distintas. En un sistema operativo multitarea, m\u00faltiples instancias de un programa pueden ejecutarse simult\u00e1neamente. Cada instancia es un proceso separado. Ve\u00e1mos cu\u00e1ntos procesos estaban en ejecuci\u00f3n en el momento de la captura, para ello usaremos el comando pslist que nos imprime todos los procesos que est\u00e1n corriendo. /opt/volatility -f dump.raw pslist > procesos Ahora hacemos un cat a procesos que es el fichero d\u00f3nde hemos dumpeado el output del comando pslist . Nosotros queremos contar las l\u00edneas a partir de la n\u00famero 3 que es d\u00f3nde empieza el primer proceso, para ello escribiremos: sed -i \"1,2d\" procesos wc -l procesos Y la respuesta es 43 procesos . Solution: flag{43} Challenge 3 Description \u00bfCu\u00e1ntas claves de registro hay en el ra\u00edz del hive SYSTEM? (incluyendo las vol\u00e1tiles) Solution Para hallar cu\u00e1ntas claves de registro hay en un hive en concreto, debemos usar la opci\u00f3n printkey que seg\u00fan el man de Volatility nos lo define de la siguiente manera: printkey : Print a Registry Key, and its subkeys and values Sin embargo, nosotros debemos especificar a que hive queremos que se realice esta funci\u00f3n. Para ello, veamos si printkey nos facilita el poder especificar una hive en concreto. /opt/volatility printkey --help Observamos que nos permite especificar un hive en concreto a trav\u00e9s de su hive offset virtual . Por tanto, veamos con hivelist cu\u00e1l es su offset virutal de SYSTEM /opt/volatility -f dump.raw --profile=Win7SP1x64 hivelist Ahora s\u00ed, podemos usar el par\u00e1metro printkey -o especificando el **offset hive (virtual) /opt/volatility -f dump.raw --profile=Win7SP1x64 printkey -o 0xfffff8a000024010 Hay un total de 9 subkeys. Solution: flag{9} Challenge 4: Password Description Necesitamos la contrase\u00f1a de inicio de sesi\u00f3n del usuario Admin. \u00bfCu\u00e1l es? Solution Debemos saber que al igual que en Linux existe el /etc/shadow d\u00f3nde se almacenan las passwords cifradas y nos da informaci\u00f3n de los usuarios que hay en el sistema, en Windows tambi\u00e9n tenemos este fichero que se encuentra en la siguiente ruta %SystemRoot%/system32/config/SAM . SAM Ahora bien, veamos que existe una opci\u00f3n en volatility que nos permite dumpear la informaci\u00f3n de este fichero. /opt/volatility -f dump.raw --profile=Win7SP1x64 hashdump > hash Ahora entra en uso la herramienta John the ripper para crackear las passwords. Si buscamos por internet el tipo de hash con el que windows almacena las passwords encontramos lo siguiente: Por tanto, vamos a especificar en la opci\u00f3n --format en John que sea de tipo NT . john --show --format=NT hash Con --show le decimos que nos muestre si ha conseguido crackear el hash Solution : flag{administrador}","title":"Retos"},{"location":"forense/retos/#retos-de-forense","text":"","title":"Retos de Forense"},{"location":"forense/retos/#challenge-1-profile","text":"","title":"Challenge 1: Profile"},{"location":"forense/retos/#description","text":"Determina el perfil de S.O. a utilizar con este volcado de memoria.","title":"Description"},{"location":"forense/retos/#solution","text":"Lo primero es ver antes que tipo de SO nos encontramos, para ello el comando imageinfo nos ofrece una visi\u00f3n general sobre el volcado de memoria. Nosotros para determinar el profile del SO nos vamos a fijar en el campo que pone Suggested Profile . /opt/volatility -f dump.raw imageinfo C\u00f3mo vemos en la figura estamos ante un Windows 7 Service Pack 1 de 64bits . Respuesta: flag{Win7SP1x64}","title":"Solution"},{"location":"forense/retos/#challenge-2-procesos","text":"","title":"Challenge 2: Procesos"},{"location":"forense/retos/#description_1","text":"\u00bfCu\u00e1ntos procesos hab\u00eda en ejecuci\u00f3n en el equipo en el momento de la captura?","title":"Description"},{"location":"forense/retos/#solution_1","text":"\u00bf Qu\u00e9 es un proceso? Un proceso es una instancia de un programa en ejecuci\u00f3n. Programas y procesos son entidades distintas. En un sistema operativo multitarea, m\u00faltiples instancias de un programa pueden ejecutarse simult\u00e1neamente. Cada instancia es un proceso separado. Ve\u00e1mos cu\u00e1ntos procesos estaban en ejecuci\u00f3n en el momento de la captura, para ello usaremos el comando pslist que nos imprime todos los procesos que est\u00e1n corriendo. /opt/volatility -f dump.raw pslist > procesos Ahora hacemos un cat a procesos que es el fichero d\u00f3nde hemos dumpeado el output del comando pslist . Nosotros queremos contar las l\u00edneas a partir de la n\u00famero 3 que es d\u00f3nde empieza el primer proceso, para ello escribiremos: sed -i \"1,2d\" procesos wc -l procesos Y la respuesta es 43 procesos . Solution: flag{43}","title":"Solution"},{"location":"forense/retos/#challenge-3","text":"","title":"Challenge 3"},{"location":"forense/retos/#description_2","text":"\u00bfCu\u00e1ntas claves de registro hay en el ra\u00edz del hive SYSTEM? (incluyendo las vol\u00e1tiles)","title":"Description"},{"location":"forense/retos/#solution_2","text":"Para hallar cu\u00e1ntas claves de registro hay en un hive en concreto, debemos usar la opci\u00f3n printkey que seg\u00fan el man de Volatility nos lo define de la siguiente manera: printkey : Print a Registry Key, and its subkeys and values Sin embargo, nosotros debemos especificar a que hive queremos que se realice esta funci\u00f3n. Para ello, veamos si printkey nos facilita el poder especificar una hive en concreto. /opt/volatility printkey --help Observamos que nos permite especificar un hive en concreto a trav\u00e9s de su hive offset virtual . Por tanto, veamos con hivelist cu\u00e1l es su offset virutal de SYSTEM /opt/volatility -f dump.raw --profile=Win7SP1x64 hivelist Ahora s\u00ed, podemos usar el par\u00e1metro printkey -o especificando el **offset hive (virtual) /opt/volatility -f dump.raw --profile=Win7SP1x64 printkey -o 0xfffff8a000024010 Hay un total de 9 subkeys. Solution: flag{9}","title":"Solution"},{"location":"forense/retos/#challenge-4-password","text":"","title":"Challenge 4: Password"},{"location":"forense/retos/#description_3","text":"Necesitamos la contrase\u00f1a de inicio de sesi\u00f3n del usuario Admin. \u00bfCu\u00e1l es?","title":"Description"},{"location":"forense/retos/#solution_3","text":"Debemos saber que al igual que en Linux existe el /etc/shadow d\u00f3nde se almacenan las passwords cifradas y nos da informaci\u00f3n de los usuarios que hay en el sistema, en Windows tambi\u00e9n tenemos este fichero que se encuentra en la siguiente ruta %SystemRoot%/system32/config/SAM . SAM Ahora bien, veamos que existe una opci\u00f3n en volatility que nos permite dumpear la informaci\u00f3n de este fichero. /opt/volatility -f dump.raw --profile=Win7SP1x64 hashdump > hash Ahora entra en uso la herramienta John the ripper para crackear las passwords. Si buscamos por internet el tipo de hash con el que windows almacena las passwords encontramos lo siguiente: Por tanto, vamos a especificar en la opci\u00f3n --format en John que sea de tipo NT . john --show --format=NT hash Con --show le decimos que nos muestre si ha conseguido crackear el hash Solution : flag{administrador}","title":"Solution"},{"location":"forense/tools/","text":"Volatility es una herramienta forense de c\u00f3digo abierto para la respuesta a incidentes y el an\u00e1lisis de malware. Est\u00e1 escrito en Python y es compatible con Microsoft Windows, Mac OS X y Linux. Es capaz de instalarse en cualquier sistema sobre el cual se disponga de Python, por lo que es compatible con multitud de sistemas ya utilicemos Windows, Linux o Mac, lo que facilita mucho el uso del mismo en diferentes sistemas operativos. Dispone adem\u00e1s de una API extensible y programable, donde adem\u00e1s de los propios m\u00f3dulos que ofrece el propio Volatility es posible la creaci\u00f3n de m\u00f3dulos personalizados con el fin de llevar a cabo an\u00e1lisis de una forma autom\u00e1tica, la creaci\u00f3n de una interfaz web o GUI personalizada o simplemente explorar la memoria del kernel de una forma automatizada. Los analistas pueden agregar nuevos espacios de direcciones, complementos, estructuras de datos y superposiciones para soldar el marco de trabajo a las necesidades de un momento dado.","title":"Herramientas"},{"location":"redes/","text":"Retos basados en red Dentro de esta modalidad suelen incluirse retos entre los cuales se tiene una captura de red. Esta captura de red generalmente, simula un entorno real donde existen ataques y transferencias de ficheros.","title":"Inicio"},{"location":"redes/#retos-basados-en-red","text":"Dentro de esta modalidad suelen incluirse retos entre los cuales se tiene una captura de red. Esta captura de red generalmente, simula un entorno real donde existen ataques y transferencias de ficheros.","title":"Retos basados en red"},{"location":"redes/retos/","text":"Retos de red Challenge 1 Descripci\u00f3n En el fichero net1.pcapng tenemos una traza de red de la captura de una empresa que sospecha de ataques dentro de la red. Se tiene que determinar cual es el protocolo usado, la versi\u00f3n del servidor atacado y el usuario que esta intentando ser la v\u00edctima. El formato de la flag es: flag{protocolo:version:usuario} Soluci\u00f3n Para este reto, obtenemos una captura de Wireshark, por lo tanto lo primero que tenemos que hacer es abrirla con este programa para ver si podemos obtener alguna pista. Para poder filtrar por protocolo podemos utilizar la pesta\u00f1a que nos facilita Wireshark, de esta forma a la hora de cambiar el orden podemos distinguir los protocolos: TCP, FTP Otra opci\u00f3n para poder ver los protocolos, con sus jerarqu\u00edas, podemos verlo en el men\u00fa de estadisticas -> jerarqu\u00edas de protocolos. . Analizando estos resultados, podemos deducir que el protocolo atacado es FTP puesto de los que podemos observar es el \u00fanico que puede ser atacado mediante un ataque de usuario y contrase\u00f1a (como nos indica el reto) Para filtrar los paquetes, de forma que solo podemos observar los correspondientes a FTP, podemos utilizar el filtro ftp . Filtrando por estos paquetes, podemos ver que en los primeros tenemos la versi\u00f3n del servidor siendo esta vsFTPd 3.0.3 . Por \u00faltimo tenemos que determinar cual ha sido el usuario que est\u00e1 atacando. Al estar los paquetes por filtro podemos ver que todos corresponde al usuario hromero , por lo tanto ser\u00e1 este el \u00fanico que esta intentando iniciar sesi\u00f3n y por lo tanto la v\u00edctima del ataque. En el caso de esta captura, es sencillo de determinar. Sin embargo, si tuvi\u00e9ramos muchos paquetes FTP. Podr\u00edamos utilizar el filtro del paquete con el comando usuario. Esto puede sonar muy complejo, pero bastar\u00eda con seleccionar el campo dentro del paquete y con el menu de opciones, seleccionar aplicar como filtro Obtenemos el resultado siguiente al aplicar el filtro La flag del reto por lo tanto ser\u00eda: flag{ftp:vsFTPd 3.0.3:hromero} Challenge 2 Descripci\u00f3n Hemos detectado muchos intentos de inicio de sesi\u00f3n, para un usuario determinado. Se sospecha que el atacante a conseguido entrar en el sistema. Tenemos que determinar la cantidad de intentos de inicio de sesi\u00f3n y en el caso de que se infiltrara la contrase\u00f1a. En el caso de que no haya conseguido entrar, la contrase\u00f1a tendr\u00e1 el valor null El formato de la flag es: flag{n\u00famero de intentos: contrase\u00f1a} Soluci\u00f3n Para solucionar este reto, partimos de la captura del anterior. Para poder resolverlo tenemos que comprobar cu\u00e1ntos intentos de sesi\u00f3n se han realizado y cu\u00e1l ha sido la contrase\u00f1a (en el caso de que haya sido encontrada). Para poder solucionarlo, vamos a utilizar los conocimientos del reto anterior: * Sabemos que FTP no cifra el contenido (por lo tanto podemos obtener el usuario / Contrase\u00f1a) * Como hemos visto en el reto anterior, en la captura tenemos commando de FTP (como el comando USER) * En el caso de que haya conexi\u00f3n (v\u00e1lida o no) obtendremos alg\u00fan mensaje de respuesta. Teniendo todo esto en cuenta, vamos a utilizar la capacidad de Wireshark, para ir creando filtros con la opci\u00f3n de utilizar como filtro con los campos de un paquete La idea es poder eliminar todos aquellos paquetes que no nos den informaci\u00f3n \u00fatil, estos paquetes que queremos eliminar son: 1.- Los que nos dan informaci\u00f3n del servidor (puesto que ya lo sabes) 2.- Aquellos paquetes que nos dan informaci\u00f3n del usuario que intenta acceder (puesto que ahora no es relevante) Adem\u00e1s, como hemos realizado antes, vamos a filtrar por protocolo ftp Obtenemos el siguiente resultado Para poder ir seleccionando los filtros, se realiza como se ve en la imagen. Buscamos en campo que queremos seleccionar (en este caso el protocolo ftp con los correspondientes campos) y con el bot\u00f3n derecho seleccionamos los paquetes para aplicarlos como filtro. Este filtro ser\u00e1 ...and not selected para que se agregue al filtro. [!] Tener en cuenta que es ... and not selected porque son los paquetes que queremos descartar. Tenemos el filtro final (((((ftp) && !(ftp.request.command == \"USER\")))) && !(ftp.response.code == 220)) && !(ftp.request.command == \"PASS\") Aplicando el filtro tenemos el siguiente resultado Con este filtro, ya tenemos la cantidad de paquetes que tienen como resultado de Login Incorrect Para obtener la contrase\u00f1a, tenemos que seleccionar el paquete de Login successful y con el bot\u00f3n derecho utilizar la opci\u00f3n de Seguir flujo TCP Al seleccionarlo tenemos el siguiente resultado: Tenemos as\u00ed la contrase\u00f1a del usuario. Por lo tanto la flag ser\u00eda: flag{16:password}","title":"Retos"},{"location":"redes/retos/#retos-de-red","text":"","title":"Retos de red"},{"location":"redes/retos/#challenge-1","text":"","title":"Challenge 1"},{"location":"redes/retos/#descripcion","text":"En el fichero net1.pcapng tenemos una traza de red de la captura de una empresa que sospecha de ataques dentro de la red. Se tiene que determinar cual es el protocolo usado, la versi\u00f3n del servidor atacado y el usuario que esta intentando ser la v\u00edctima. El formato de la flag es: flag{protocolo:version:usuario}","title":"Descripci\u00f3n"},{"location":"redes/retos/#solucion","text":"Para este reto, obtenemos una captura de Wireshark, por lo tanto lo primero que tenemos que hacer es abrirla con este programa para ver si podemos obtener alguna pista. Para poder filtrar por protocolo podemos utilizar la pesta\u00f1a que nos facilita Wireshark, de esta forma a la hora de cambiar el orden podemos distinguir los protocolos: TCP, FTP Otra opci\u00f3n para poder ver los protocolos, con sus jerarqu\u00edas, podemos verlo en el men\u00fa de estadisticas -> jerarqu\u00edas de protocolos. . Analizando estos resultados, podemos deducir que el protocolo atacado es FTP puesto de los que podemos observar es el \u00fanico que puede ser atacado mediante un ataque de usuario y contrase\u00f1a (como nos indica el reto) Para filtrar los paquetes, de forma que solo podemos observar los correspondientes a FTP, podemos utilizar el filtro ftp . Filtrando por estos paquetes, podemos ver que en los primeros tenemos la versi\u00f3n del servidor siendo esta vsFTPd 3.0.3 . Por \u00faltimo tenemos que determinar cual ha sido el usuario que est\u00e1 atacando. Al estar los paquetes por filtro podemos ver que todos corresponde al usuario hromero , por lo tanto ser\u00e1 este el \u00fanico que esta intentando iniciar sesi\u00f3n y por lo tanto la v\u00edctima del ataque. En el caso de esta captura, es sencillo de determinar. Sin embargo, si tuvi\u00e9ramos muchos paquetes FTP. Podr\u00edamos utilizar el filtro del paquete con el comando usuario. Esto puede sonar muy complejo, pero bastar\u00eda con seleccionar el campo dentro del paquete y con el menu de opciones, seleccionar aplicar como filtro Obtenemos el resultado siguiente al aplicar el filtro La flag del reto por lo tanto ser\u00eda: flag{ftp:vsFTPd 3.0.3:hromero}","title":"Soluci\u00f3n"},{"location":"redes/retos/#challenge-2","text":"","title":"Challenge 2"},{"location":"redes/retos/#descripcion_1","text":"Hemos detectado muchos intentos de inicio de sesi\u00f3n, para un usuario determinado. Se sospecha que el atacante a conseguido entrar en el sistema. Tenemos que determinar la cantidad de intentos de inicio de sesi\u00f3n y en el caso de que se infiltrara la contrase\u00f1a. En el caso de que no haya conseguido entrar, la contrase\u00f1a tendr\u00e1 el valor null El formato de la flag es: flag{n\u00famero de intentos: contrase\u00f1a}","title":"Descripci\u00f3n"},{"location":"redes/retos/#solucion_1","text":"Para solucionar este reto, partimos de la captura del anterior. Para poder resolverlo tenemos que comprobar cu\u00e1ntos intentos de sesi\u00f3n se han realizado y cu\u00e1l ha sido la contrase\u00f1a (en el caso de que haya sido encontrada). Para poder solucionarlo, vamos a utilizar los conocimientos del reto anterior: * Sabemos que FTP no cifra el contenido (por lo tanto podemos obtener el usuario / Contrase\u00f1a) * Como hemos visto en el reto anterior, en la captura tenemos commando de FTP (como el comando USER) * En el caso de que haya conexi\u00f3n (v\u00e1lida o no) obtendremos alg\u00fan mensaje de respuesta. Teniendo todo esto en cuenta, vamos a utilizar la capacidad de Wireshark, para ir creando filtros con la opci\u00f3n de utilizar como filtro con los campos de un paquete La idea es poder eliminar todos aquellos paquetes que no nos den informaci\u00f3n \u00fatil, estos paquetes que queremos eliminar son: 1.- Los que nos dan informaci\u00f3n del servidor (puesto que ya lo sabes) 2.- Aquellos paquetes que nos dan informaci\u00f3n del usuario que intenta acceder (puesto que ahora no es relevante) Adem\u00e1s, como hemos realizado antes, vamos a filtrar por protocolo ftp Obtenemos el siguiente resultado Para poder ir seleccionando los filtros, se realiza como se ve en la imagen. Buscamos en campo que queremos seleccionar (en este caso el protocolo ftp con los correspondientes campos) y con el bot\u00f3n derecho seleccionamos los paquetes para aplicarlos como filtro. Este filtro ser\u00e1 ...and not selected para que se agregue al filtro. [!] Tener en cuenta que es ... and not selected porque son los paquetes que queremos descartar. Tenemos el filtro final (((((ftp) && !(ftp.request.command == \"USER\")))) && !(ftp.response.code == 220)) && !(ftp.request.command == \"PASS\") Aplicando el filtro tenemos el siguiente resultado Con este filtro, ya tenemos la cantidad de paquetes que tienen como resultado de Login Incorrect Para obtener la contrase\u00f1a, tenemos que seleccionar el paquete de Login successful y con el bot\u00f3n derecho utilizar la opci\u00f3n de Seguir flujo TCP Al seleccionarlo tenemos el siguiente resultado: Tenemos as\u00ed la contrase\u00f1a del usuario. Por lo tanto la flag ser\u00eda: flag{16:password}","title":"Soluci\u00f3n"},{"location":"redes/tools/","text":"Herramientas para an\u00e1lisis de red Wireshark Wireshark es una herramienta que nos permite analizar protocolos de red. Es una de las herramientas m\u00e1s extendidas a lo largo del mundo debido a la facilidad de uso y utilidad de la misma. Otra utilidad de Wireshark es que nos permite capturar los paquetes que estan circulando por la red, es decir, act\u00faa com un sniffer para poder obtener una captura de red para analizarla posteriormente. Instalaci\u00f3n Si nos encontramos en distribuciones Linux especializadas en seguridad (como Kali y Parrot) esta herramienta esta instalada. De lo contrario, podemos obtener los binarios desde su web . En entornos Linux es posbile encontrarla en los repositorios e instalarla con apt sudo apt-get install wireshark Inicio Al inciar Wireshark obtenemos una ventana similar a esta: Podemos distinguir dos secciones: La parte superior, correspondiente a las capturas que hemos abierto recientemente. La parte inferiorn, donde podemos seleccionar una de las interfaces que tenemos en nuestra m\u00e1quina para poder capturar Al abrir una captura de Wireshark pasaremos a visualizar el contenido. Obtenemos una venrana parecida a la siguiente: A partir de aqu\u00ed podemos comenzar a analizar la captura.","title":"Herramientas"},{"location":"redes/tools/#herramientas-para-analisis-de-red","text":"","title":"Herramientas para an\u00e1lisis de red"},{"location":"redes/tools/#wireshark","text":"Wireshark es una herramienta que nos permite analizar protocolos de red. Es una de las herramientas m\u00e1s extendidas a lo largo del mundo debido a la facilidad de uso y utilidad de la misma. Otra utilidad de Wireshark es que nos permite capturar los paquetes que estan circulando por la red, es decir, act\u00faa com un sniffer para poder obtener una captura de red para analizarla posteriormente.","title":"Wireshark"},{"location":"redes/tools/#instalacion","text":"Si nos encontramos en distribuciones Linux especializadas en seguridad (como Kali y Parrot) esta herramienta esta instalada. De lo contrario, podemos obtener los binarios desde su web . En entornos Linux es posbile encontrarla en los repositorios e instalarla con apt sudo apt-get install wireshark","title":"Instalaci\u00f3n"},{"location":"redes/tools/#inicio","text":"Al inciar Wireshark obtenemos una ventana similar a esta: Podemos distinguir dos secciones: La parte superior, correspondiente a las capturas que hemos abierto recientemente. La parte inferiorn, donde podemos seleccionar una de las interfaces que tenemos en nuestra m\u00e1quina para poder capturar Al abrir una captura de Wireshark pasaremos a visualizar el contenido. Obtenemos una venrana parecida a la siguiente: A partir de aqu\u00ed podemos comenzar a analizar la captura.","title":"Inicio"},{"location":"stego/","text":"La Esteganograf\u00eda es una forma de ocultar informaci\u00f3n diferente a la Criptograf\u00eda. Con una diferencia, en la Esteganograf\u00eda ocultamos la informaci\u00f3n de forma que nadie sepa que esta ah\u00ed en lugar de encadenarla como har\u00edamos con la Criptograf\u00eda. Podr\u00edamos decir que, en la Esteganograf\u00eda, camuflamos la informaci\u00f3n a la vista para que nadie pueda verla. A trav\u00e9s de la Esteganograf\u00eda podemos ocultar diferentes tipos de archivo, como programas, texto etc en archivos .mp4, .mp3 o im\u00e1genes. De forma que podamos ocultar algo que solo queramos saber nosotros que esta ah\u00ed o con fines menos \u00e9ticos, como adjuntar un archivo infectado con c\u00f3digo malicioso y posteriormente ocultarlo en una imagen que, al abrirla, la v\u00edctima quedar\u00eda contagiada.","title":"Inicio"},{"location":"stego/retos/","text":"Desaf\u00edos de Esteganograf\u00eda Challenge 1 En este primer reto nos da una imagen y debemos de conseguir la flag a trav\u00e9s de la imagen proporcionada. Lo primero que se debe comprobar siempre es que la imagen no haya sido modificada anteriormente. Para ello vamos a acceder a la siguiente p\u00e1gina: http://fotoforensics.com/ Subimos la imagen proporcionada y encontramos lo siguiente: Observamos que en esa parte ha sido modificada, si abrimos la imagen y hacemos Zoom en esa zona, podemos encontrar lo siguiente: PASS=TOTORO , por tanto ya tenemos la flag del desaf\u00edo: flag{TOTORO} Challenge 2 En el segundo reto tambi\u00e9n nos proporciona una imgen, por tanto vamos a realizar el mismo proceso que el anterior. Sin embargo, no ha habido \u00e9xito en este caso. El siguiente paso que se suele usar es tirar del comando strings el cual nos proporciona cadenas legibles de una imagen. Si hacemos uso de strings, observamos lo siguiente: Tendr\u00edamos la flag de este segundo reto: flag{HAHAHA} Challenge 3 Enunciado El siguiente reto nos proporciona esta imagen, pero sabemos que hay algo detr\u00e1s de ella y necesitamos encontrarlo. Soluci\u00f3n propuesta Descargamos la imagen photo.jpg proporcionada en la interfaz web. Como siempre, verificamos que se trata de una imagen JPG, con la herramienta file o la herramienta exiftool : $ file photo.jpg photo.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 96x96, segment length 16, Exif Standard: [TIFF image data, big-endian, direntries=2], progressive, precision 8, 1920x1280, components 3 Aparentemente, el fichero es lo que parece, una imagen JPEG. Pasamos a analizar la imagen con alguna herramienta online para determinar si esconde algo que no se ve a simple vista. Alguna de estas herramientas son: 29a.ch Photo Forensic imageforensic.org fotoforensic.com Utilizando fotoforensic.com no vemos nada extra\u00f1o en el Error Level Analysis (ELA) que nos muestre una posible modificaci\u00f3n de la imagen. Sin embargo, si utilizamos la herramienta strings para extraer el el contenido ASCII del fichero binario photo.jpg , obtenemos algo muy interesante: $ strings data/photo.jpg | tee tmp/step0.txt JFIF Exif http://ns.adobe.com/xap/1.0/ <?xpacket begin=' ' id='W5M0MpCehiHzreSzNTczkc9d'?> ... ... =dSP57 >3TO0 ad`w \"https://www.dropbox.com/s/io1kaqznal2c10y/corrupted.zip?dl=0\" Vemos que la \u00faltima l\u00ednea obtenida del comando es un enlace a dropbox. Si descargamos el fichero de de Dropbox, mediante wget o copiando y pegando el enlace en el navegador e intentamos extraerlo con el comando unzip veremos que este fichero est\u00e1 protegido con contrase\u00f1a. $ wget $(tail -1 tmp/step0.txt | sed 's/\\\"//g') -O tmp/step1.zip ... ... $ unzip tmp/step1.zip Archive: tmp/step1.zip [tmp/step1.zip] FOR0x.png password: Como vimos en el taller, podemos usar la herramienta john para obtener la contrase\u00f1a del ZIP, pero antes debemos transformar este fichero ZIP en un formato legible por dicha herramienta. Para ello usamos la herramienta zip2john , que no est\u00e1 incluida en Kali Linux por defecto pero puede ser instalada mediate la orden sudo apt install zip2john : $ zip2john tmp/step1.zip > tmp/step2.zip.txt Ahora si, estamos en condiciones para obtener la contrase\u00f1a con john : $ john tmp/step2.zip.txt Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Will run 2 OpenMP threads Proceeding with single, rules:Single Press 'q' or Ctrl-C to abort, almost any other key for status Almost done: Processing the remaining buffered candidate passwords, if any. Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist Proceeding with incremental:ASCII Si dejamos que john act\u00fae, veremos que se demora much\u00edsimo, por lo que podemos intentar realizar un ataque de diccionario en lugar de un ataque de fuerza bruta puro. Para ello, cancelamos la ejecuci\u00f3n actual, pulsando Ctrl+C y utilizamos john con alg\u00fan diccionario. Podemos usar el diccionario rockyou.txt, con las contrase\u00f1as m\u00e1s usadas en el mundo, el cual se encuentra alojado en /usr/share/wordlist/rockyou.txt.gz en Kali Linux (Puede descargarse de github si no est\u00e1 disponible en la distribuci\u00f3n utilizada) Este fichero est\u00e1 comprimido en formado GZIP, por lo que para usar este diccionario en john , tenemos que descomprimirlo primero, utilizando la instrucci\u00f3n gzip : $ gzip -cd /usr/share/wordlists/rockyou.txt.gz | john --stdin step2.zip.txt Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Will run 2 OpenMP threads Press Ctrl-C to abort, or send SIGUSR1 to john process for status pumpkinpie (step1.zip/FOR0x.png) 1g 0:00:00:00 33.33g/s 682666p/s 682666c/s 682666C/s christal..michelle4 Use the \"--show\" option to display all of the cracked passwords reliably Session completed Ya tenemos la contrase\u00f1a del fichero zip ( pumpkinpie ), as\u00ed que pasamos a descomprimirlo: $ unzip -P \"pumpkinpie\" tmp/step1.zip -d tmp/ Archive: tmp/step1.zip inflating: tmp/FOR0x.png Al descomprimir el ZIP, aparentemente hemos obtenido una imagen PNG, pero si volvemos a usar la herramienta file , vemos que no lo es: $ file tmp/FOR0x.png tmp/FOR0x.png: data El comando `file` nos indica que es un fichero binario `data`. Utilizando de nuevo la herramienta strings , observamos que la segunda l\u00ednea devuelta por el comando es jfif . $ strings tmp/FOR0x.png ..xx jfif bExif ... ... s_$` &[^b' ;wV; Si entramos en [esta](5) p\u00e1gina de wikipedia y buscamos `jfif`, veremos que se trata de la cabecera de una imagen JPEG, pero corrupta, pues la cabecera no se corresponde completamente. Podemos comprobar de forma m\u00e1s exacta que la cabecera del fichero JPEG est\u00e1 corrupta utilizando un visor hexadecimal como hexdump y filtrando la primera l\u00ednea: $ hexdump -C tmp/FOR0x.png | head -1 00000000 2e 2e 78 78 00 10 6a 66 69 66 00 01 38 35 2e 00 |..xx..jfif..85..| Observamos que los 4 primeros bytes no se corresponden con la cabecera est\u00e1ndar de un fichero JPEG. Para recuperar este fichero, tendremos que restaurar la cabecera, utilizando un editor hexadecimal como hexedit (no est\u00e1 instalado por defecto en Kali Linux, se puede instalar con el comando sudo apt install hexedit : $ cp tmp/FOR0x.png solution.jpeg $ hexedit solution.jpeg Esto nos abrir\u00e1 un editor interactivo en el que podremos editar los 4 primeros bytes, como se ve en la siguiente imagen: Una vez corregidos los cuatro primeros bytes, plusamos Ctrl+x y respondemos y para guardar los cambios. Una vez editado el fichero, solo tenemos que abrirlo con nuetro visor de im\u00e1genes favorito y veremos la solici\u00f3n al challenge en la esquina inferior derecha: $ feh solution.jpeg Resumen de comandos para impacientes strings data/photo.jpg | tee tmp/step0.txt wget $(tail -1 tmp/step0.txt | sed 's/\\\"//g') -O tmp/step1.zip zip2john tmp/step1.zip > tmp/step2.zip.txt gzip -cd /usr/share/wordlist/rockyou.txt.gz | john --stdin tmp/step2.zip.txt unzip -P \"pumpkinpie\" tmp/step1.zip -d tmp/ cp tmp/FOR0x.png solution.jpeg hexedit solution.jpeg Cambiamos 2e 2e 78 78 00 10 por ff d8 ff e0 00 10 . Guardamos el fichero con Ctrl-x y pulsamos y . Abrimos el fichero solution.jpeg con un visor de im\u00e1genes. Documentado este \u00faltimo reto por Rafael Savariego Fern\u00e1ndez : Rafael","title":"Retos"},{"location":"stego/retos/#desafios-de-esteganografia","text":"","title":"Desaf\u00edos de Esteganograf\u00eda"},{"location":"stego/retos/#challenge-1","text":"En este primer reto nos da una imagen y debemos de conseguir la flag a trav\u00e9s de la imagen proporcionada. Lo primero que se debe comprobar siempre es que la imagen no haya sido modificada anteriormente. Para ello vamos a acceder a la siguiente p\u00e1gina: http://fotoforensics.com/ Subimos la imagen proporcionada y encontramos lo siguiente: Observamos que en esa parte ha sido modificada, si abrimos la imagen y hacemos Zoom en esa zona, podemos encontrar lo siguiente: PASS=TOTORO , por tanto ya tenemos la flag del desaf\u00edo: flag{TOTORO}","title":"Challenge 1"},{"location":"stego/retos/#challenge-2","text":"En el segundo reto tambi\u00e9n nos proporciona una imgen, por tanto vamos a realizar el mismo proceso que el anterior. Sin embargo, no ha habido \u00e9xito en este caso. El siguiente paso que se suele usar es tirar del comando strings el cual nos proporciona cadenas legibles de una imagen. Si hacemos uso de strings, observamos lo siguiente: Tendr\u00edamos la flag de este segundo reto: flag{HAHAHA}","title":"Challenge 2"},{"location":"stego/retos/#challenge-3","text":"","title":"Challenge 3"},{"location":"stego/retos/#enunciado","text":"El siguiente reto nos proporciona esta imagen, pero sabemos que hay algo detr\u00e1s de ella y necesitamos encontrarlo.","title":"Enunciado"},{"location":"stego/retos/#solucion-propuesta","text":"Descargamos la imagen photo.jpg proporcionada en la interfaz web. Como siempre, verificamos que se trata de una imagen JPG, con la herramienta file o la herramienta exiftool : $ file photo.jpg photo.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 96x96, segment length 16, Exif Standard: [TIFF image data, big-endian, direntries=2], progressive, precision 8, 1920x1280, components 3 Aparentemente, el fichero es lo que parece, una imagen JPEG. Pasamos a analizar la imagen con alguna herramienta online para determinar si esconde algo que no se ve a simple vista. Alguna de estas herramientas son: 29a.ch Photo Forensic imageforensic.org fotoforensic.com Utilizando fotoforensic.com no vemos nada extra\u00f1o en el Error Level Analysis (ELA) que nos muestre una posible modificaci\u00f3n de la imagen. Sin embargo, si utilizamos la herramienta strings para extraer el el contenido ASCII del fichero binario photo.jpg , obtenemos algo muy interesante: $ strings data/photo.jpg | tee tmp/step0.txt JFIF Exif http://ns.adobe.com/xap/1.0/ <?xpacket begin=' ' id='W5M0MpCehiHzreSzNTczkc9d'?> ... ... =dSP57 >3TO0 ad`w \"https://www.dropbox.com/s/io1kaqznal2c10y/corrupted.zip?dl=0\" Vemos que la \u00faltima l\u00ednea obtenida del comando es un enlace a dropbox. Si descargamos el fichero de de Dropbox, mediante wget o copiando y pegando el enlace en el navegador e intentamos extraerlo con el comando unzip veremos que este fichero est\u00e1 protegido con contrase\u00f1a. $ wget $(tail -1 tmp/step0.txt | sed 's/\\\"//g') -O tmp/step1.zip ... ... $ unzip tmp/step1.zip Archive: tmp/step1.zip [tmp/step1.zip] FOR0x.png password: Como vimos en el taller, podemos usar la herramienta john para obtener la contrase\u00f1a del ZIP, pero antes debemos transformar este fichero ZIP en un formato legible por dicha herramienta. Para ello usamos la herramienta zip2john , que no est\u00e1 incluida en Kali Linux por defecto pero puede ser instalada mediate la orden sudo apt install zip2john : $ zip2john tmp/step1.zip > tmp/step2.zip.txt Ahora si, estamos en condiciones para obtener la contrase\u00f1a con john : $ john tmp/step2.zip.txt Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Will run 2 OpenMP threads Proceeding with single, rules:Single Press 'q' or Ctrl-C to abort, almost any other key for status Almost done: Processing the remaining buffered candidate passwords, if any. Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist Proceeding with incremental:ASCII Si dejamos que john act\u00fae, veremos que se demora much\u00edsimo, por lo que podemos intentar realizar un ataque de diccionario en lugar de un ataque de fuerza bruta puro. Para ello, cancelamos la ejecuci\u00f3n actual, pulsando Ctrl+C y utilizamos john con alg\u00fan diccionario. Podemos usar el diccionario rockyou.txt, con las contrase\u00f1as m\u00e1s usadas en el mundo, el cual se encuentra alojado en /usr/share/wordlist/rockyou.txt.gz en Kali Linux (Puede descargarse de github si no est\u00e1 disponible en la distribuci\u00f3n utilizada) Este fichero est\u00e1 comprimido en formado GZIP, por lo que para usar este diccionario en john , tenemos que descomprimirlo primero, utilizando la instrucci\u00f3n gzip : $ gzip -cd /usr/share/wordlists/rockyou.txt.gz | john --stdin step2.zip.txt Using default input encoding: UTF-8 Loaded 1 password hash (PKZIP [32/64]) Will run 2 OpenMP threads Press Ctrl-C to abort, or send SIGUSR1 to john process for status pumpkinpie (step1.zip/FOR0x.png) 1g 0:00:00:00 33.33g/s 682666p/s 682666c/s 682666C/s christal..michelle4 Use the \"--show\" option to display all of the cracked passwords reliably Session completed Ya tenemos la contrase\u00f1a del fichero zip ( pumpkinpie ), as\u00ed que pasamos a descomprimirlo: $ unzip -P \"pumpkinpie\" tmp/step1.zip -d tmp/ Archive: tmp/step1.zip inflating: tmp/FOR0x.png Al descomprimir el ZIP, aparentemente hemos obtenido una imagen PNG, pero si volvemos a usar la herramienta file , vemos que no lo es: $ file tmp/FOR0x.png tmp/FOR0x.png: data El comando `file` nos indica que es un fichero binario `data`. Utilizando de nuevo la herramienta strings , observamos que la segunda l\u00ednea devuelta por el comando es jfif . $ strings tmp/FOR0x.png ..xx jfif bExif ... ... s_$` &[^b' ;wV; Si entramos en [esta](5) p\u00e1gina de wikipedia y buscamos `jfif`, veremos que se trata de la cabecera de una imagen JPEG, pero corrupta, pues la cabecera no se corresponde completamente. Podemos comprobar de forma m\u00e1s exacta que la cabecera del fichero JPEG est\u00e1 corrupta utilizando un visor hexadecimal como hexdump y filtrando la primera l\u00ednea: $ hexdump -C tmp/FOR0x.png | head -1 00000000 2e 2e 78 78 00 10 6a 66 69 66 00 01 38 35 2e 00 |..xx..jfif..85..| Observamos que los 4 primeros bytes no se corresponden con la cabecera est\u00e1ndar de un fichero JPEG. Para recuperar este fichero, tendremos que restaurar la cabecera, utilizando un editor hexadecimal como hexedit (no est\u00e1 instalado por defecto en Kali Linux, se puede instalar con el comando sudo apt install hexedit : $ cp tmp/FOR0x.png solution.jpeg $ hexedit solution.jpeg Esto nos abrir\u00e1 un editor interactivo en el que podremos editar los 4 primeros bytes, como se ve en la siguiente imagen: Una vez corregidos los cuatro primeros bytes, plusamos Ctrl+x y respondemos y para guardar los cambios. Una vez editado el fichero, solo tenemos que abrirlo con nuetro visor de im\u00e1genes favorito y veremos la solici\u00f3n al challenge en la esquina inferior derecha: $ feh solution.jpeg","title":"Soluci\u00f3n propuesta"},{"location":"stego/retos/#resumen-de-comandos-para-impacientes","text":"strings data/photo.jpg | tee tmp/step0.txt wget $(tail -1 tmp/step0.txt | sed 's/\\\"//g') -O tmp/step1.zip zip2john tmp/step1.zip > tmp/step2.zip.txt gzip -cd /usr/share/wordlist/rockyou.txt.gz | john --stdin tmp/step2.zip.txt unzip -P \"pumpkinpie\" tmp/step1.zip -d tmp/ cp tmp/FOR0x.png solution.jpeg hexedit solution.jpeg Cambiamos 2e 2e 78 78 00 10 por ff d8 ff e0 00 10 . Guardamos el fichero con Ctrl-x y pulsamos y . Abrimos el fichero solution.jpeg con un visor de im\u00e1genes. Documentado este \u00faltimo reto por Rafael Savariego Fern\u00e1ndez : Rafael","title":"Resumen de comandos para impacientes"},{"location":"stego/tools/","text":"file : Identifica el tipo de fichero. exiftool : Identifica el tipo de fichero. strings : Obtiene cadenas en ficheros. ghex : Editor hexadecimal para buscar informaci\u00f3n. binwalk : An\u00e1lisis de binarios, usar con \u2013e para extracci\u00f3n de datos. Openstego , DeepSound , StegExpose , Steghide Herramientas de estegoan\u00e1lisis.","title":"Herramientas"},{"location":"web/","text":"Retos basados en Web Los retos basados en web pueden ser muy variados. Generalmente estan formados por un servidor web (del cual te dan la direcci\u00f3n ip con el puerto) donde existe una vulnerabilidad que se tiene que descubrir y explotar. Tipos de vulnerabilidades web De acuerdo a la OWASP (Open Web Application Security Project) las principales vulnerabilidades web que se encuentran en aplicaciones web son: Para ver en profundidad este listado de vulnerabilidades, esta disponible en la web oficial de OWASP","title":"Inicio"},{"location":"web/#retos-basados-en-web","text":"Los retos basados en web pueden ser muy variados. Generalmente estan formados por un servidor web (del cual te dan la direcci\u00f3n ip con el puerto) donde existe una vulnerabilidad que se tiene que descubrir y explotar.","title":"Retos basados en Web"},{"location":"web/#tipos-de-vulnerabilidades-web","text":"De acuerdo a la OWASP (Open Web Application Security Project) las principales vulnerabilidades web que se encuentran en aplicaciones web son: Para ver en profundidad este listado de vulnerabilidades, esta disponible en la web oficial de OWASP","title":"Tipos de vulnerabilidades web"},{"location":"web/tools/","text":"Herramientas Burp Suite Caracter\u00edsticas Burp Suite es una herramienta que nos facilita las tareas a la hora de examinar las peticiones web. La herramienta (principal) que nos ofrece Burp suite es la posibilidad de establecer un proxy entre nuestro equipo y cualquier petici\u00f3n web que realizamos hacia un servidor web. Esta herramienta nos permite modificar cualquier petici\u00f3n. Adem\u00e1s podemos utilizar otras funcionalidades como: 1.- Intruder: Nos permite modificar las peticiones web, por ejemplo, centr\u00e1ndonos en un punto concreto de la petici\u00f3n, de forma que podemos probar diferentes valores. La caracter\u00edstica principal es realizar ataques automatizados . 2.- Repeater: Nos permite reenviar las peticiones web modificando los valores y observar la respuesta del servidor de forma muy sencilla (sin tener que salid de la aplicaci\u00f3n) 3.- Target: Esta funcionalidad nos ofrece la posibilidad de escanear la aplicaci\u00f3n web en busca de informaci\u00f3n sobre la misma 4.- Sequencer: Esta funcionalidad nos permite analizar la aleatoriedad de las partes de la aplicaci\u00f3n como los token de sessi\u00f3n 5.- Decoder: Nos permite Codificar / Decodificar diferentes Strings (\u00fatil por ejemplo para realizar encoding en formularios) 6.- Comparer: Integra la funcionalidad del comando diff para peticiones web 7.- DOM Invader: Nos permite encontrar vulnerabilidades DOM XSS en la web. 8.- Logger: Nos permite tener un control de todas las peticiones hechas por burp suite Instalaci\u00f3n y configuraci\u00f3n Podemos obtener la version _community__ desde la . Obtendremos un paquete compilado .jar el cual podremos abrir en cualquier sistema que tengamos Java instalado. Desde terminal, podemos usar el comando java -jar burp.jar Como resultado obtendremos la posibilidad de crear un proyecto (donde se almacenar\u00e1 toda la informaci\u00f3n del an\u00e1lisis realizado a una aplicaci\u00f3n web). En el caso de realizar peque\u00f1as pruebas, podemos seleccionar la opci\u00f3n de temporal project Configurar la funcionalidad proxy Una vez abierto podemos configurar la funcionalidad de proxy. En la barra superior tenemos que seleccionar la opci\u00f3n de proxy. Dentro de este men\u00fa seleccionamos la opci\u00f3n de Options . Obtendremos una ventana igual a la siguiente. Dentro de la secci\u00f3n Proxy Listeners tendremos que agregar un nuevo elemento. Al agregar un proxy nuevo tendremos que configurarlo. Lo m\u00e1s importante a configurar es el puerto donde va a escuchar el proxy. Este campo se corresponde al Bind to Port del siguiente formulario. Por defecto Burp Suite configura el puerto 8080. En el caso de que tengamos corriendo alg\u00fan servicio en este puerto,puede causar problema por lo cual podemos escoger cualquiera de los disponibles. Una vez seleccionado el puerto se crear\u00e1 el proxy. Solo queda\u00eda configurarlo dentro de nuestro navegador. Configuraci\u00f3n de proxy en Firefox Dentro de Firefox tenemos que irnos a las opciones y seleccionar la funcionalidad de proxy. Introducimos los datos como se muestran en pantalla. Teniendo en cuenta el puerto que hemos configurado anteriormente en Burp Suite Una vez realizado todos los pasos, activamos el modo intercept y obtendremos todos los paquetes que accedamos en el navegador. Configuraci\u00f3n de SSL Cuando tenemos que atacar cualquier p\u00e1gina con SSL. El navegador nos dar\u00e1 un error al estar trabajando con el proxy de Burp Suite (ya que este no tiene SSL configurado) El error es el siguiente: Para poder solucionar esto, tenemos que generar un certificado CA. Este certificado nos lo genera burp suite en la configuraci\u00f3n del proxy. Tenemos que generar el archivo en Import/Export CA certificate . Esta opci\u00f3n nos generar\u00e1 un archivo que tendremos que importar posteriormente. Dentro de esta opci\u00f3n tenemos que exportar el formato como DER Para importar el certificado tenemos que irnos a las opciones del navegador e importarlo dentro de las configuraciones de seguridad. Al importarlo tendremos el siguiente Warning Esto es causado porque el certificado de CA no es aprobado por una entidad reconocida (este generado por nosotros mismos). como sabemos que ester certificado es nuestro, no corremos ning\u00fan riesgo y por lo tanto podemos importarlo. Una vez importado lo tendremos en el listado bajo el nombre PortSwingger Tenemos que darle a la opci\u00f3n de edit trust y seleccionar ambas opciones. Con todo esto configurado podremos acceder a cualquier p\u00e1gina con SSL capturando las peticiones sin problema.","title":"Herramientas"},{"location":"web/tools/#herramientas","text":"","title":"Herramientas"},{"location":"web/tools/#burp-suite","text":"","title":"Burp Suite"},{"location":"web/tools/#caracteristicas","text":"Burp Suite es una herramienta que nos facilita las tareas a la hora de examinar las peticiones web. La herramienta (principal) que nos ofrece Burp suite es la posibilidad de establecer un proxy entre nuestro equipo y cualquier petici\u00f3n web que realizamos hacia un servidor web. Esta herramienta nos permite modificar cualquier petici\u00f3n. Adem\u00e1s podemos utilizar otras funcionalidades como: 1.- Intruder: Nos permite modificar las peticiones web, por ejemplo, centr\u00e1ndonos en un punto concreto de la petici\u00f3n, de forma que podemos probar diferentes valores. La caracter\u00edstica principal es realizar ataques automatizados . 2.- Repeater: Nos permite reenviar las peticiones web modificando los valores y observar la respuesta del servidor de forma muy sencilla (sin tener que salid de la aplicaci\u00f3n) 3.- Target: Esta funcionalidad nos ofrece la posibilidad de escanear la aplicaci\u00f3n web en busca de informaci\u00f3n sobre la misma 4.- Sequencer: Esta funcionalidad nos permite analizar la aleatoriedad de las partes de la aplicaci\u00f3n como los token de sessi\u00f3n 5.- Decoder: Nos permite Codificar / Decodificar diferentes Strings (\u00fatil por ejemplo para realizar encoding en formularios) 6.- Comparer: Integra la funcionalidad del comando diff para peticiones web 7.- DOM Invader: Nos permite encontrar vulnerabilidades DOM XSS en la web. 8.- Logger: Nos permite tener un control de todas las peticiones hechas por burp suite","title":"Caracter\u00edsticas"},{"location":"web/tools/#instalacion-y-configuracion","text":"Podemos obtener la version _community__ desde la . Obtendremos un paquete compilado .jar el cual podremos abrir en cualquier sistema que tengamos Java instalado. Desde terminal, podemos usar el comando java -jar burp.jar Como resultado obtendremos la posibilidad de crear un proyecto (donde se almacenar\u00e1 toda la informaci\u00f3n del an\u00e1lisis realizado a una aplicaci\u00f3n web). En el caso de realizar peque\u00f1as pruebas, podemos seleccionar la opci\u00f3n de temporal project","title":"Instalaci\u00f3n y configuraci\u00f3n"},{"location":"web/tools/#configurar-la-funcionalidad-proxy","text":"Una vez abierto podemos configurar la funcionalidad de proxy. En la barra superior tenemos que seleccionar la opci\u00f3n de proxy. Dentro de este men\u00fa seleccionamos la opci\u00f3n de Options . Obtendremos una ventana igual a la siguiente. Dentro de la secci\u00f3n Proxy Listeners tendremos que agregar un nuevo elemento. Al agregar un proxy nuevo tendremos que configurarlo. Lo m\u00e1s importante a configurar es el puerto donde va a escuchar el proxy. Este campo se corresponde al Bind to Port del siguiente formulario. Por defecto Burp Suite configura el puerto 8080. En el caso de que tengamos corriendo alg\u00fan servicio en este puerto,puede causar problema por lo cual podemos escoger cualquiera de los disponibles. Una vez seleccionado el puerto se crear\u00e1 el proxy. Solo queda\u00eda configurarlo dentro de nuestro navegador.","title":"Configurar la funcionalidad proxy"},{"location":"web/tools/#configuracion-de-proxy-en-firefox","text":"Dentro de Firefox tenemos que irnos a las opciones y seleccionar la funcionalidad de proxy. Introducimos los datos como se muestran en pantalla. Teniendo en cuenta el puerto que hemos configurado anteriormente en Burp Suite Una vez realizado todos los pasos, activamos el modo intercept y obtendremos todos los paquetes que accedamos en el navegador.","title":"Configuraci\u00f3n de proxy en Firefox"},{"location":"web/tools/#configuracion-de-ssl","text":"Cuando tenemos que atacar cualquier p\u00e1gina con SSL. El navegador nos dar\u00e1 un error al estar trabajando con el proxy de Burp Suite (ya que este no tiene SSL configurado) El error es el siguiente: Para poder solucionar esto, tenemos que generar un certificado CA. Este certificado nos lo genera burp suite en la configuraci\u00f3n del proxy. Tenemos que generar el archivo en Import/Export CA certificate . Esta opci\u00f3n nos generar\u00e1 un archivo que tendremos que importar posteriormente. Dentro de esta opci\u00f3n tenemos que exportar el formato como DER Para importar el certificado tenemos que irnos a las opciones del navegador e importarlo dentro de las configuraciones de seguridad. Al importarlo tendremos el siguiente Warning Esto es causado porque el certificado de CA no es aprobado por una entidad reconocida (este generado por nosotros mismos). como sabemos que ester certificado es nuestro, no corremos ning\u00fan riesgo y por lo tanto podemos importarlo. Una vez importado lo tendremos en el listado bajo el nombre PortSwingger Tenemos que darle a la opci\u00f3n de edit trust y seleccionar ambas opciones. Con todo esto configurado podremos acceder a cualquier p\u00e1gina con SSL capturando las peticiones sin problema.","title":"Configuraci\u00f3n de SSL"}]}